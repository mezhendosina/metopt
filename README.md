
# Решатель задач линейного программирования
Меньшенин Евгений Андреевич

МЕТОПТ 1.2

## Алгоритм решения

Программа решает ЗЛП с использованием двухфазного симплекс-метода.

### Псевдокод

```
АЛГОРИТМ двухфазного симплекс-метода:

ФАЗА I: Поиск начального допустимого решения

1. ПРИВЕСТИ_К_КАНОНИЧЕСКОЙ_ФОРМЕ(исходная_задача):
   - Если задача на минимизацию, преобразовать в задачу на максимизацию (умножить целевую функцию на -1).
   - Преобразовать все ограничения-неравенства в равенства путем добавления/вычитания балансных (слабых) переменных.
   - Убедиться, что все правые части ограничений (RHS) неотрицательны.

2. СОЗДАТЬ_ВСПОМОГАТЕЛЬНУЮ_ЗАДАЧУ(каноническая_задача):
   - Добавить искусственные переменные к ограничениям, которые изначально были типа ">=" или "=".
   - Создать вспомогательную целевую функцию: минимизировать сумму искусственных переменных.

3. РЕШИТЬ_СИМПЛЕКС_МЕТОДОМ(вспомогательная_задача):
   - Создать начальную симплекс-таблицу.
   - Итеративно выполнять опорные операции (пивоты) до достижения оптимального решения.
   - ЕСЛИ оптимальное значение вспомогательной целевой функции > 0:
       - Исходная задача не имеет допустимых решений. ВЫХОД.
   - ИНАЧЕ:
       - Найдено допустимое решение для исходной задачи.

ФАЗА II: Решение исходной задачи

4. ПЕРЕЙТИ_К_ОСНОВНОЙ_ЗАДАЧЕ(таблица_из_фазы_I):
   - Удалить столбцы, соответствующие искусственным переменным.
   - Заменить вспомогательную целевую функцию на исходную.

5. РЕШИТЬ_СИМПЛЕКС_МЕТОДОМ(основная_задача):
   - Выполнять опорные операции до тех пор, пока:
     - не будет найдено оптимальное решение (все коэффициенты в строке целевой функции неотрицательны),
     - или не будет установлено, что задача неограничена (невозможно выбрать ведущую строку).

6. ВЫВЕСТИ_РЕЗУЛЬТАТ:
   - Отобразить оптимальные значения переменных и значение целевой функции.
```

## Инструкция по запуску

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL-вашего-репозитория>
    cd <имя-папки-репозитория>
    ```

2.  **Установите зависимости:**
    Убедитесь, что у вас установлен Python 3 и библиотека NumPy.
    ```bash
    pip install numpy
    ```

3.  **Подготовьте входной файл:**
    Создайте текстовый файл (например, `problem.txt`), описывающий вашу задачу линейного программирования в следующем формате:

    ```
    max
    2
    3 5
    3
    1 0 <= 4
    0 2 <= 12
    3 2 <= 18
    ```
    - **Строка 1:** Тип оптимизации (`min` или `max`).
    - **Строка 2:** Количество переменных.
    - **Строка 3:** Коэффициенты целевой функции, разделенные пробелами.
    - **Строка 4:** Количество ограничений.
    - **Следующие строки:** Ограничения в формате `коэффициенты <=/>=/= правая_часть`.

4.  **Запустите программу:**
    Выполните скрипт `main.py` из командной строки, передав ему имя входного и выходного файлов.

    ```bash
    python main.py problem.txt result.txt
    ```
    - `problem.txt` - это ваш входной файл.
    - `result.txt` - файл, в который будет записан результат.

## Рефлексивный вывод

При выполнении данной работы я получил ценный опыт в реализации классического алгоритма оптимизации — симплекс-метода.

**Что было полезного:**
- **Глубокое понимание алгоритма:** Реализация заставила детально разобраться во всех тонкостях двухфазного симплекс-метода, включая обработку различных типов ограничений, введение искусственных переменных и переход между фазами.
- **Практика в NumPy:** Проект стал отличной возможностью для применения библиотеки NumPy для матричных операций, что значительно упростило и ускорило вычисления.
- **Структурирование кода:** Разделение логики на отдельные модули (`canonical_form.py`, `auxilaty_problem.py`, `solve_simplex.py`) помогло создать более чистый и поддерживаемый код.

**Трудности и их преодоление:**
- **Отладка опорных операций:** Самой сложной частью была корректная реализация опорной операции (пивота) и обновления симплекс-таблицы. Ошибки на этом этапе приводили к неверным результатам или зацикливанию. Проблема была решена путем пошаговой отладки с использованием небольших, легко проверяемых вручную примеров.
- **Переход от Фазы I к Фазе II:** Было непросто правильно восстановить исходную целевую функцию в симплекс-таблице после завершения вспомогательной задачи. Помогло внимательное изучение теоретического материала и аккуратное манипулирование индексами переменных.
- **Обработка вырожденных случаев:** Изначально алгоритм не всегда корректно обрабатывал случаи, когда задача не имела решения или была неограниченной. Добавление проверок на каждом шаге (например, проверка значения целевой функции вспомогательной задачи) позволило сделать решатель более надежным.

В целом, работа была очень полезной и дала хорошее представление о том, как теоретические методы оптимизации воплощаются в программном коде.